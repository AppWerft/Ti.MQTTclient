/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package de.appwerft.mqtt;

import java.net.URI;
import java.net.URISyntaxException;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.titanium.TiC;
import org.appcelerator.titanium.util.TiConvert;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.MqttClient;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;

@Kroll.proxy(creatableInModule = MqttModule.class)
public class MQTTClientProxy extends KrollProxy {
	// Standard Debugging variables
	private static final String LCAT = "MQTT";
	protected long timeToWait = -1;
	public URI serverUri = null;
	private static final String SANDBOX = "tcp://iot.eclipse.org:1883";
	public String clientId = "Java_Test";
	private MqttClient aClient;
	MemoryPersistence persistence = new MemoryPersistence();
	MqttConnectOptions options = new MqttConnectOptions();

	private KrollFunction onloadCallback = null;

	// https://eclipse.org/paho/clients/java/
	public MQTTClientProxy() {
		super();
	}

	private void readOptions(KrollDict options) {
		Log.d(LCAT, "handleCreationDict started");
		if (options.containsKeyAndNotNull("url")) {
			try {
				serverUri = new URI(TiConvert.toString(options
						.get(TiC.PROPERTY_URL)));
			} catch (URISyntaxException e) {
				e.printStackTrace();
			}
		}
		if (options.containsKeyAndNotNull("clientId")) {
			Log.d(LCAT, "clientId detected");
			clientId = options.getString("clientId");
		}
		if (serverUri == null)
			try {
				serverUri = new URI(SANDBOX);
			} catch (URISyntaxException e) {
				e.printStackTrace();
			}
	}

	@Override
	public void handleCreationDict(KrollDict options) {
		readOptions(options);
		super.handleCreationDict(options);
	}

	/*
	 * JS: MQTTClient.subscribe({ topicFilter : "example", qos :
	 * MQTTClient.QOS_AT_LEAST_ONCE, onload : function(_e) { console.log(_e)} })
	 */
	@Kroll.method
	public void subscribe(final KrollDict args) throws MqttException {
		IMqttMessageListener messageListener = new IMqttMessageListener() {
			@Override
			public void messageArrived(String topic, MqttMessage message)
					throws Exception {
				Object onload;
				KrollDict payload = new KrollDict();
				payload.put("message", message.toString());
				if (args.containsKeyAndNotNull("onload")) {
					onload = args.get("onload");
					if (onload instanceof KrollFunction) {
						onloadCallback = (KrollFunction) onload;
					}
					onloadCallback.call(getKrollObject(), payload);
				}

				Log.d("LCAT",
						"Message: " + topic + " : "
								+ new String(message.getPayload()));
			}
		};
		if (args.containsKeyAndNotNull("topics")) {
			aClient.subscribe(args.getStringArray("topics"), new int[] { 1 });
		}
		if (args.containsKeyAndNotNull("topic")) {
			aClient.subscribe(new String[] { args.getString("topic") },
					new int[] { 1 },
					new IMqttMessageListener[] { messageListener });
		}
	}

	@Kroll.method
	public void unsubscribe(KrollDict args) throws MqttException {
		if (args.containsKeyAndNotNull("topic")) {
			String topicFilter = args.getString("topic");
			aClient.unsubscribe(new String[] { topicFilter });
		}
		if (args.containsKeyAndNotNull("topics")) {
			String[] topicFilters = args.getStringArray("topics");
			aClient.unsubscribe(topicFilters);
		}

	}

	@Kroll.method
	public void publish(KrollDict args) {
		String topic = "DEFAULTTOPIC", content = "DEFAULTMESSAGE";
		int qos = 2;
		if (args.containsKeyAndNotNull("topic")) {
			topic = args.getString("topic");
		}
		if (args.containsKeyAndNotNull("message")) {
			content = args.getString("message");
		}
		if (args.containsKeyAndNotNull("qos")) {
			qos = args.getInt("qos");
		}
		MqttMessage message = new MqttMessage(content.getBytes());
		message.setQos(qos);
		try {
			aClient.publish(topic, message);
		} catch (MqttException e) {
			e.printStackTrace();
		}
	}

	@Kroll.method
	public void connect(@Kroll.argument(optional = true) final KrollDict args) {
		if (args != null && !args.isEmpty()) {
			readOptions(args);
		}
		Log.d(LCAT, "connect to " + clientId + "@" + serverUri.toString());
		try {
			aClient = new MqttClient(serverUri.toString(), clientId,
					persistence);

			aClient.connect(options);
			Log.d(LCAT, "new MqttClient created " + serverUri.toString());
		} catch (MqttException e) {
			e.printStackTrace();
		}
	}

	@Kroll.method
	public void close() throws MqttException {
		aClient.close();
	}

	@Kroll.method
	public String getClientId() {
		return aClient.getClientId();
	}

	@Kroll.method
	public String getServerURI() {
		return aClient.getServerURI().toString();
	}

	@Kroll.method
	public String getCurrentServerURI() {
		return aClient.getCurrentServerURI().toString();
	}

	@Kroll.method
	public String getTopic(String topic) {
		return aClient.getTopic(topic).toString();
	}

	@Kroll.method
	public void disconnect() {
		if (aClient != null)
			try {
				aClient.disconnect();
			} catch (MqttException e) {
				e.printStackTrace();
			}
	}

	@Kroll.method
	public boolean isConnected() {
		return aClient.isConnected();
	}

	@Kroll.method
	public void reconnect() throws MqttException {
		if (aClient != null)
			try {
				aClient.reconnect();
			} catch (MqttException e) {
				e.printStackTrace();
			}
	}

	public long getTimeToWait() {
		return this.timeToWait;
	}
}